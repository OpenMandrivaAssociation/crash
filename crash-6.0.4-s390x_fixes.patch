--- crash-6.0.4/s390x.c.orig
+++ crash-6.0.4/s390x.c
@@ -556,12 +556,25 @@ static ulong _kl_rsg_table_deref_s390x(u
 	if ((entry & 0xcULL) != (level << 2))
 		return 0;
 	/* Check if the region table entry has the invalid bit set. */
-	if (entry & 0x40ULL)
+	if (entry & 0x20ULL)
 		return 0;
 	/* Region table entry is valid and well formed. */
 	return entry;
 }
 
+/* Check for swap entry */
+static int swap_entry(ulong entry)
+{
+	if (THIS_KERNEL_VERSION < LINUX(2,6,19)) {
+		if ((entry & 0x601ULL) == 0x600ULL)
+			return 1;
+	} else {
+		if ((entry & 0x403ULL) == 0x403ULL)
+			return 1;
+	}
+	return 0;
+}
+
 /* Page table traversal function */
 static ulong _kl_pg_table_deref_s390x(ulong vaddr, ulong table)
 {
@@ -571,13 +584,11 @@ static ulong _kl_pg_table_deref_s390x(ul
 	readmem(table + offset, KVADDR, &entry, sizeof(entry), "entry",
 		FAULT_ON_ERROR);
 	/*
-	 * Check if the page table entry could be read and doesn't have
-	 * any of the reserved bits set.
+	 * Return zero if the page table entry has any of the reserved bits
+	 * set (0x900) or the invalid bit (0x400) is set and it is not a
+	 * swap entry.
 	 */
-	if (entry & 0x900ULL)
-		return 0;
-	/* Check if the page table entry has the invalid bit set. */
-	if (entry & 0x400ULL)
+	if ((entry & 0xd00ULL) && !swap_entry(entry))
 		return 0;
 	/* Page table entry is valid and well formed. */
 	return entry;
@@ -589,6 +600,7 @@ int s390x_vtop(ulong table, ulong vaddr,
 	ulong entry, paddr;
 	int level, len;
 
+	*phys_addr = 0;
 	/*
 	 * Walk the region and segment tables.
 	 * We assume that the table length field in the asce is set to the
@@ -607,7 +619,7 @@ int s390x_vtop(ulong table, ulong vaddr,
 	while (level >= 0) {
 		entry = _kl_rsg_table_deref_s390x(vaddr, table, len, level);
 		if (!entry)
-			return 0;
+			return FALSE;
 		table = entry & ~0xfffULL;
 		len = entry & 0x3ULL;
 		level--;
@@ -625,6 +637,12 @@ int s390x_vtop(ulong table, ulong vaddr,
 
 	/* Isolate the page origin from the page table entry. */
 	paddr = entry & ~0xfffULL;
+	/* For swap entries we have to return FALSE and phys_addr = PTE */
+	if (swap_entry(entry)) {
+		*phys_addr = entry;
+		return FALSE;
+	}
+
 
 	/* Add the page offset and return the final value. */
 	*phys_addr = paddr + (vaddr & 0xfffULL);
@@ -1285,7 +1303,7 @@ s390x_get_stack_frame(struct bt_info *bt
 
 	/* get the stack pointer */
 	if(esp){
-		if(s390x_has_cpu(bt)){
+		if (!ACTIVE() && s390x_has_cpu(bt)) {
 			ksp = ULONG(lowcore + MEMBER_OFFSET("_lowcore",
 				"gpregs_save_area") + (15 * S390X_WORD_SIZE));
 		} else {
